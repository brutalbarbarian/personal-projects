package com.lwan.bo;

import java.util.EnumSet;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import java.util.Vector;

import com.lwan.util.ClassUtil;

import javafx.beans.property.Property;
import javafx.beans.property.ReadOnlyProperty;
import javafx.beans.property.SimpleObjectProperty;
import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;

/**
 * <h1>****GUIDE TO BOObjects ****</h1>
 * 
 * <h3>DataStructure</h3>
 * <p>
 * BOObjects follow a clearly defined hierarchy. When any attribute is modified along the hierarchy, the owner of that attribute will be
 * notified of a change. This in turn notifies the owner of that owner until there is no more owners (i.e. hit the root of the hierarchy).
 * </p>
 * <ul>
 * <li>Each BOObject has an owner</li>
 * <li>Each BOObject can have children. These children can either be another BOObject, a BOAttribute, or a BOSet. Note that BOAttribute and
 * BOSet both extend from BOObject and thus shares similar behavior and properties to BOObject.</li>
 * <li>The hierarchy for any BOObject must be constructed within the method {@link #createAttributes()}.</li>
 * </ul>
 * 
 * <h3>Events</h3>
 * <p>When a modification occurs to any BOObject, a modification event will be fired. All BOObjects will automatically fire off a modification
 * event of its parent, which forms a recursive loop up the hierarchy. All BOObjects listen to any modification events it fires. AllowNotifications
 * can be set to false for a particular BOObject, in which case it will ignore the call to fire events. Thus it will not receive any events and won't
 * pass any events on up the hierarchy.
 * </p>
 * 
 * <h3>Attributes</h3>
 * <p>
 * Attributes are the leaves as part of the data structure. An attribute stores a simple value i.e. a String or an Integer etc. Each attribute
 * can have only one parent - BOObject it's bound to. Whenever the value of an attribute is modified, it will throw an event to its owner.
 * </p>
 * <ul>
 * <li>The field name for an attribute should always be named starting with a lower case letter and should always be private</li>
 * <li>The accessor method should always be read only, and be fully camel cased.</li>
 * </ul>
 * 
 * <h3>Property Declaration</h3>
 * <ul>
 * <li>Properties should always start with a lower case letter and be fully lower case. use underscore to separate words if needed.</li>
 * <li>Property should be accessed in 2 possible ways. A public accessor and a private accessor. The public accessor should always
 * have the public modifier, and fully camel cased.</li>
 * <li>A private accessor is only necessary if the public accessor is ReadOnly. This should always have the prefix of an underscore, and
 * otherwise follows the exact same name as the property field.</li></ul>
 * <p>
 * Properties should have nothing to do with the data structure, and thus will throw no events to the BOObjects directly. They do not
 * belong to the data hierarchy but rather are attributes associated with the object itself.
 * </p>
 * 
 * <h3>State</h3>
 * 
 *  
 *  
 * @author Brutalbarbarian
 *
 */
public abstract class BOObject implements ModifiedEventListener{
	/* Property Declarations */
	
	private Property<BOObject> owner;
	private Property<Boolean> active;
	private Property<String> name;
	private Property<String> tag;
	private Property<Boolean> allow_notifications;
	private Property<Set<State>> state;
	
	/* Property Accessor Methods */
	public ReadOnlyProperty<BOObject> Owner() {
		return _owner();
	}
	public ReadOnlyProperty<String> Name() {
		return _name();
	}
	public ReadOnlyProperty<Set<State>> State(){
		return _state();
	}
	/** 
	 * Active represents if this objects is in use. 
	 */
	public Property<Boolean> Active() {
		if (active == null) {
			active = new SimpleObjectProperty<>();
		}
		return active;
	}
	public Property<String> Tag() {
		if (tag == null) {
			tag = new SimpleObjectProperty<>();
		}
		return tag;
	}
	/** 
	 * Use this flag to disable notifications if needed.
	 * This will effectively disable fireModified for this object only. 
	 */
	public Property<Boolean> AllowNotifications() {
		if (allow_notifications == null) {
			allow_notifications = new SimpleObjectProperty<>();
		}
		return allow_notifications;
	}
	
	/* Private Property Accessor Methods */
	private Property<BOObject> _owner() {
		if (owner == null) {
			owner = new SimpleObjectProperty<>();
		}
		return owner;
	}
	private Property<String> _name() {
		if(name == null) {
			name = new SimpleObjectProperty<>();
		}
		return name;
	}	
	private Property<Set<State>> _state() {
		if (state == null) {
			state = new SimpleObjectProperty<>();
			state.setValue(new HashSet<State>());
		}
		return state;
	}

	/* Private Fields  */
	// Children of this object. This should never be exposed.
	private HashMap<String, BOObject> children;
	// Temporary tag used by handleActive and clear to avoid a potentially
	// extremely expensive operation
	private boolean isSettingActive;
	// List of listeners to any modification to this object.
	// Note that the owner of this object will not be in this list, and thus will always be notified.
	// i.e. cannot be removed.
	private Vector<ModifiedEventListener> listeners;
	
	
	public BOObject(BOObject owner, String name) {
		children = new HashMap<>();
		listeners = new Vector<>();
		_name().setValue(name);
		_owner().setValue(owner);
		AllowNotifications().setValue(true);
		isSettingActive = false;
		Active().addListener(new ChangeListener<Boolean>() {
			public void changed(ObservableValue<? extends Boolean> value,
					Boolean oldValue, Boolean newValue) {
				handleActive(newValue);
			}			
		});
		
		initialise();
	}
	
	private final void initialise() {
		createAttributes();
		// Ensures active state is false to begin with. This will also ensure all children are inactive as well.
		Active().setValue(false);
		clearAttributes();
	}
	
	/**
	 * Get a direct child of this object with name equal to the parameter string
	 * 
	 * @param name
	 * @return
	 */
	public BOObject getChildByName(String name) {
		return children.get(name);
	}
	
	/**
	 * Get the first owner traveling up the hierarchy with the same class as the passed in class
	 * 
	 * @param parentClass
	 * @return
	 */
	@SuppressWarnings("unchecked")
	public <T extends BOObject> T getOwnerByClass(Class<T> parentClass) {
		if (ClassUtil.isSuperclassOf(parentClass, getClass())) {
			return (T)this;
		} else if (Owner().getValue() != null) {
			return Owner().getValue().getOwnerByClass(parentClass);
		} else {
			return null;
		}
	}
	
	/**
	 * Handle active by default will clear an object if passed in false for isActive.
	 * Otherwise will proceed to call populateAttributes.
	 * This can be overridden to provide any extra functionality upon changing the active state
	 * of an object.
	 * 
	 * @param isActive
	 */
	protected void handleActive(Boolean isActive) {
		if (isActive) {
			populateAttributes();
		} else {
			isSettingActive = true;
			clear();
			isSettingActive = false;
		}
		// Set the active state of all children to match this
		for (BOObject child : children.values()) {
			child.Active().setValue(isActive);
		}
	}
	
	/**
	 * Safer to call this to ensure a BOObject is activated.
	 * This will activate the object if and only if the object isn't already activated.
	 * 
	 */
	public void ensureActive() {
		if (!Active().getValue()) {
			Active().setValue(true);
		}
	}
	

	/**
	 * Fire an event to this object, which will in turn pass the event up the hierarchy,
	 * as well as notifying any listeners listening to this object.
	 * Note that this will not handleModified to be called for this object.
	 * 
	 * @param source
	 */
	public final void fireModified(ModifiedEvent event) {
		if (AllowNotifications().getValue()) {
			handleModified(event);
			
			BOObject owner = Owner().getValue();
			if (owner != null) {
				Owner().getValue().fireModified(event);
			}
			for(ModifiedEventListener listener : listeners) {
				listener.handleModified(event);
			}
		}
	}
	
	/**
	 * This is different from clearAttributes from that this should clear away all values as opposed to
	 * setting them to default values.</br>
	 */
	protected void clear() {
		// If settingActive is true, clear will be called for all children anyway. No need to loop.
		if (!isSettingActive) {
			for (BOObject child : children.values()) {
				child.clear();
			}
		}
	}
	
	/**
	 * Add a BOObject as a child of this object.
	 * This should only ever be called in createAttributes 
	 * 
	 * @param object
	 */
	protected final void addAsChild(BOObject object) {
		children.put(object.Name().getValue(), object);
	}
	
	/**
	 * Add a listener which listens to any changes to this object or below in the hierarchy
	 * 
	 * @param listener
	 */
	public void addListener(ModifiedEventListener listener) {
		listeners.add(listener);
	}
	
	/**
	 * Removes a modification listener.
	 * 
	 * @param listener
	 */
	public void removeListener(ModifiedEventListener listener) {
		listeners.remove(listener);
	}
	
	public void save() {
		// save children first... or save this first? its really up to 
		// if its a database...makes sense to save this first, followed by children. this way they link up
		// for foreign keys
		
		// if modified... then call doSave. Otherwise ignore
		doSave();
		for (BOObject child: children.values()) {
			if (!(child instanceof BOAttribute)) {
				child.save();
			}
		}
	}
	
	protected void doSave() {
		
	}
	
	public abstract void delete();
	
	/**
	 * This is used to populate all child attributes and objects.
	 * It is up to the implementation of the object to decide to populate with default values or to load values from some source. 
	 * 
	 */
	protected abstract void populateAttributes();
	
	/**
	 * Create all child attribute objects
	 */
	protected abstract void createAttributes();
	
	/**
	 * Clear all child attribute objects. This is effectively setting default values into all attributes.
	 */
	protected abstract void clearAttributes();
	
	/**
	 * Event thrown when something down the hierarchy is modified.
	 * 
	 * @param source
	 */
	public abstract void handleModified(ModifiedEvent source);
}
