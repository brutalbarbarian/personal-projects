package com.lwan.musicsync.main;

import java.awt.Point;

import com.lwan.util.GenericsUtil;

import javafx.beans.value.ChangeListener;
import javafx.beans.value.ObservableValue;
import javafx.event.EventHandler;
import javafx.scene.Group;
import javafx.scene.control.ContentDisplay;
import javafx.scene.control.TableCell;
import javafx.scene.control.TableColumn;
import javafx.scene.effect.BlurType;
import javafx.scene.effect.DropShadow;
import javafx.scene.input.MouseButton;
import javafx.scene.input.MouseEvent;
import javafx.scene.layout.GridPane;
import javafx.scene.paint.Color;
import javafx.scene.shape.Polygon;
import javafx.scene.shape.Shape;
import javafx.util.Callback;

public class RatingEditingCell extends BaseEditingCell<Integer> implements EventHandler<MouseEvent> {
	private static Callback<TableColumn<AudioInfo, Integer>, TableCell<AudioInfo, Integer>> factory;
	
	public static Callback<TableColumn<AudioInfo, Integer>, TableCell<AudioInfo, Integer>> 
			getRatingEditingCellFactory(final boolean allowContextMenu) {
		if (factory == null) {
			factory = new Callback<TableColumn<AudioInfo, Integer>, TableCell<AudioInfo, Integer>>() {
				public TableCell<AudioInfo, Integer> call(TableColumn<AudioInfo, Integer> p) {
					return new RatingEditingCell(allowContextMenu);
				}
			};
        }
		return factory;
	}

	protected Star[] stars;
	protected int ratings;
	protected boolean isMouseOver;
	protected int mouseOverRatings;
	
	private RatingEditingCell (boolean allowContextMenu) {
		super(allowContextMenu);
//		setContentDisplay(ContentDisplay.GRAPHIC_ONLY);
		GridPane pane = new GridPane();
		
		stars = new Star[5];
		for (int i = 0; i < 5; i++) {
			stars[i] = new Star();
			pane.add(stars[i], i, 0);
		}
		
		setOnMouseExited(this);
		setOnMouseClicked(this);
		setOnMouseMoved(this);
		
		setGraphic(pane);
		
		itemProperty().addListener(new ChangeListener<Integer>() {
			public void changed(ObservableValue<? extends Integer> arg0,
					final Integer oldValue, final Integer newValue) {
				if(getTableRow() != null && getTableRow().getItem() != null) {
					setContentDisplay(ContentDisplay.GRAPHIC_ONLY);
				}
				ratings = GenericsUtil.Coalice(newValue, -1);
				doDisplayState();
			}
		});
		ratings = -1;
		mouseOverRatings = -1;
		isMouseOver = false;
		setCache(false);
		doDisplayState();
	}
	
	protected void doDisplayState() {
		for (int i = 0; i < 5; i++) {
			Star s = stars[i];
			if(isMouseOver) {
				s.setMouseOver(i < Math.max(ratings, mouseOverRatings));
			} else {
				s.setDefault(i < ratings);
			}
		}
	}
	
	static final Color activeDefFill = Color.GOLD;
	static final Color inactiveDefFill = Color.AZURE;
	static final Color activeDefBorder = Color.BROWN;
	static final Color inactiveDefBorder = Color.MIDNIGHTBLUE;
	
	protected class Star extends Group {
		Shape star;
		DropShadow border;
		
		Star () {
			star = createStar();
			border = (DropShadow)star.getEffect();
			
			getChildren().add(star);
		}
		
		void setMouseOver(boolean active) {
			if (active) {
				star.setFill(activeDefFill);
				border.setColor(activeDefBorder);
			} else {
				star.setFill(inactiveDefFill);
				border.setColor(activeDefBorder);
			}
		}
		
		void setDefault(boolean active) {
			if (active) {
				star.setFill(activeDefFill);
				border.setColor(activeDefBorder);
			} else {
				star.setFill(inactiveDefFill);
				border.setColor(inactiveDefBorder);
			}
		}
	}
	
	protected Shape createStar() {
		Polygon p = new Polygon(2, 10, 5, 0, 8, 10, 0, 4, 10, 4);
		DropShadow border = new DropShadow();
		border.setBlurType(BlurType.GAUSSIAN);
		border.setRadius(2);
		p.setEffect(border);
		p.setStrokeWidth(1);
		p.setStroke(Color.TRANSPARENT);
		
		return p;
	}

	static final int cutoffPoint = 10;
	
	@Override
	public void handle(MouseEvent e) {
		if (e.getEventType() == MouseEvent.MOUSE_CLICKED || e.getEventType() == MouseEvent.MOUSE_MOVED) {
			double minDist = Double.MAX_VALUE;
			int minIndex = -1;
			for (int i = 0; i < 5; i++) {
				double tmpMinDist = 
						Point.distance(e.getX(), e.getY(), 
								stars[i].getLayoutX() + 5, stars[i].getLayoutY() + 5);
				if (tmpMinDist < minDist) {
					minDist = tmpMinDist;
					minIndex = i;
				}
			}
			if (minIndex != -1) {
				if (e.getEventType() == MouseEvent.MOUSE_MOVED) {
					if (minDist < cutoffPoint) {
						isMouseOver = true;
						mouseOverRatings = minIndex + 1;
					} else {
						isMouseOver = false;
					}
				} else if (e.getEventType() == MouseEvent.MOUSE_CLICKED && 
						minDist < cutoffPoint && e.getButton() == MouseButton.PRIMARY &&
						// Don't want clicking to do anything if
						// other things are being selected.
						// This is to mainly stop anything from happening if user is
						// attempting to select multiple cells (e.g. holding shift).
						(getTableView().getSelectionModel().getSelectedItems().size() == 0 ||
						isSelected())) {
					getAudioInfo().ratingProperty().setValue(minIndex + 1);
				}
			}
		} else if (e.getEventType() == MouseEvent.MOUSE_EXITED) {
			isMouseOver = false;
		}
		// referesh the view
		doDisplayState();
	}
	
	public void startEdit() {
		// do nothing.
	}

	@Override
	public boolean allowsCellEdit() {
		return false;
	}
}

