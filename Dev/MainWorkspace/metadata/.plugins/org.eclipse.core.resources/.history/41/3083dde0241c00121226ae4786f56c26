package com.lwan.jdbc;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Vector;

/**
 * A wrapper for statement for use with MS Access DB drivers.
 * This is necessary as the Access engine cannot store stored procs,
 * and cannot execute more then one statement at a time. This object is to
 * get around that by handling the multi-statement and parameter assigning
 * part to javacode.
 * 
 * @author Brutalbarbarian
 *
 */
public class StoredProc {
	HashMap<String, Parameter> parameters;
	List<List<Parameter>> paramMap;
	List<String> statements;
	ResultSet result;
	
	/**
	 * Make sure all param names start with '@' in order for the parser to work, and only
	 * contain alphanumeric characters or underscores. Any other characters will break the parser. 
	 * 
	 * Be wary with temp tables as they cannot be dropped from the same stored proc where values are selected from and
	 * and returned within a result set. This is due to the result set remaining open, which stops
	 * the table from being dropped. Make sure to clean up any instances of temp tables after they are created 
	 * in a seperate stored proc after the result set has been closed.
	 * 
	 * @param parameters
	 * @param statements
	 * @throws SQLException 
	 */
	public StoredProc (String[] params, int[] paramTypes, String[] _statements) {
		parameters = new HashMap<>();
		// setup params
		for (int i = 0; i < params.length; i++) {
			parameters.put(params[i], new Parameter(params[i], paramTypes[i]));
		}
		// hook up params to each statement
		statements = new Vector<>(_statements.length);
		paramMap = new Vector<>(_statements.length);
		for (String origStatement : _statements) {
			List<Parameter> paramList = new Vector<>();
			char[] statement = origStatement.toCharArray();
			StringBuilder actualStatement = new StringBuilder(statement.length);
			StringBuilder param = new StringBuilder();

			boolean paramFound = false;
			
			for (int i = 0; i < statement.length; i++) {
				if (paramFound) {
					if (!(Character.isLetterOrDigit(statement[i]) || statement[i] == '_')) {
						paramList.add(parameters.get(param.toString()));
						param.setLength(0);	// reset back to 0
						paramFound = false;	
					} else {
						param.append(statement[i]);
					}
				} else if (statement[i] == '@') {
					paramFound = true;
					actualStatement.append('?');
					param.append('@');
				}
				
				if (!paramFound) {
					actualStatement.append(statement[i]);
				}
			}
			// if reached here with paramFound = true... the param must
			// have been the last item in the statement
			if (paramFound) {
				paramList.add(parameters.get(param.toString()));
			}
			
			statements.add(actualStatement.toString());
			paramMap.add(paramList);
			
		}
	}
	
	/**
	 * Note any result set returned by this must have its originating statement closed manually.
	 * This means calling resultSet.getStatement().close();</br>
	 * If nothing is closed, then all statements created from this stored proc is closed normally.
	 * 
	 * @param con
	 * @throws SQLException
	 */
	public void execute(Connection con) throws SQLException {
		result = null;	// clear previous result set
		
		if (con == null || con.isClosed()) {
			throw new SQLException("Cannot execute stored procedure without an active connection");
		}
		
		for (int i = 0; i < statements.size(); i++) {
			System.out.println(statements.get(i));
			PreparedStatement statement = con.prepareStatement(statements.get(i));
			List<Parameter> params = paramMap.get(i);
			for (int j = 1; j <= params.size(); j++) {
				Parameter param = params.get(j - 1);
				Object pValue = param.get();
				if (pValue == null) {
					statement.setNull(j, param.getType());
				} else {
					statement.setObject(j, pValue, param.getType());	
				}
			}
			statement.execute();
			ResultSet res = statement.getResultSet();
			
			if (res != null) {
				if (result != null) {
					throw new SQLException("Cannot return more then one result set");
				}
				// if there are multiple statements within this stored proc that can return resultsets,
				// only the one executed last will be kept.
				result = res;	
			} else {
				statement.close();
			}
		}
	}
	
	/**
	 * Clear all parameters.
	 * It is recommended to always call this prior to assigning any new parameters.
	 * 
	 */
	public void clearParameters() {
		for (Parameter param : parameters.values()) {
			param.set(null);
		}
	}
	
	/**
	 * Get the parameter object by name
	 * 
	 * @param name
	 * @return
	 */
	public Parameter getParamByName(String name) {
		return parameters.get(name);
	}
	
	/**
	 * Get a collection of all the parameter objects.
	 * 
	 * @return
	 */
	public Collection<Parameter> getAllParameters() {
		return parameters.values();
	}
	

	/**
	 * Get the result from the last execution.
	 * 
	 * @return
	 */
	public ResultSet getResult() {
		return result;
	}
}
